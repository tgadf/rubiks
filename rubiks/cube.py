""" Foundation of Rubik's Cube """__all__ = ["Cube"]import numpy as npfrom itertools import productimport matplotlib.pyplot as pltfrom .tilecube import TileCubefrom .cubesurface import CubeSurfacefrom .rotation import GlobalRotation, PlaneRotation, RotationTurnfrom .rotationsymmetry import RotationSymmetryclass Cube:    def __repr__(self):        return f"""Cube(nx={self.axis_plane_map['x']}, ny={self.axis_plane_map['y']}, nz={self.axis_plane_map['z']}, Ntiles={len(self.external_faces)})  Global Rotations: ==> {self.n_global_rotations} <==  {self.global_rot_groups}  Plane Rotations:  ==> {self.n_plane_rotations} <==  {self.plane_rot_groups}"""            def __init__(self, nx: int, ny: int, nz: int, verbose=False):                # Basic Axis <=> Plane mapping        axes = ["x", "y", "z"]        dim = np.array([nx, ny, nz])        axis_col_map = dict(zip(axes, [0, 1, 2]))        # List containing each global axis and plane available for rotation (number of rotations defined below)        axis_plane_map = dict(zip(axes, dim))        global_rotations = [GlobalRotation(axis) for axis in axes]        axis_plane_pairs = [(axis, plane) for axis, n_planes in axis_plane_map.items() for plane in range(n_planes)]        plane_rotations = [PlaneRotation(axis, plane) for axis, plane in axis_plane_pairs]        # Tile Cube (tc) placement maps        def gen_tc_origin(n):            return np.linspace(-(n - 1) / 2, (n - 1) / 2, n)                tc_axis_origin_map = {axis: dict(zip(range(n), gen_tc_origin(n))) for axis, n in axis_plane_map.items()}        plane_rot_coords_map = {}        axis_coord_planes_map = {}        for axis, plane_coords in tc_axis_origin_map.items():            for plane, coord in plane_coords.items():                plane_rot_coords_map[PlaneRotation(axis, plane)] = coord                axis_coord_planes_map[(axis, coord)] = plane        tc_order = list(product(*(tc_axis_origin_map.values())))                # Create Tile Cubes        def get_tc_axis_origin(axis, val):            return tc_axis_origin_map[axis][val]                tile_cubes = {}        for tc_val, tc_order_val in enumerate(tc_order):            tile_cubes[tc_val] = TileCube(name=tc_val, origin=[get_tc_axis_origin(axis, val) for axis, val in zip(axes, tc_order_val)])                # Find external faces        allFaces = {(tc.name, face.name): face.center for tc in tile_cubes.values() for face in tc.faces.values()}        face_centers = allFaces.values()        surface_coords = {}                    for (tc_name, face_name), center in allFaces.items():            external_flag = sum([np.array_equal(center, face_center) for face_center in face_centers]) == 1            tile_cubes[tc_name].setFaceAttr(face_name, "external", external_flag)        np_face_centers = np.array([center for center in face_centers])        for axis, col in axis_col_map.items():            coord_max = np.max(np_face_centers[:, col])            surface_coords[CubeSurface(axis, "+")] = coord_max            coord_min = np.min(np_face_centers[:, col])            surface_coords[CubeSurface(axis, "-")] = coord_min        # Determine rotation options        rot_sym = RotationSymmetry(*dim)        # Global Rotations        global_rot_groups = dict(zip(global_rotations, rot_sym.global_rot_groups))        global_rot_turns = {global_rot: rot_sym.get_group_rotations(rot_group) for global_rot, rot_group in global_rot_groups.items()}        global_rot_turns = [RotationTurn(global_rot, turn) for global_rot, turns in global_rot_turns.items() for turn in turns]        n_global_rotations = len(global_rot_turns)        assert n_global_rotations <= 9, f"There are more than 9 global turns! [{global_rot_turns}]"        # Plane Rotations        axis_plane_rot_groups = dict(zip(axes, rot_sym.plane_rot_groups))        plane_rot_groups = {plane_rot: axis_plane_rot_groups[plane_rot.axis] for plane_rot in plane_rotations}        plane_rot_turns = {plane_rot: rot_sym.get_group_rotations(rot_group) for plane_rot, rot_group in plane_rot_groups.items()}        plane_rot_turns = [RotationTurn(plane_rot, turn) for plane_rot, turns in plane_rot_turns.items() for turn in turns]        n_plane_rotations = len(plane_rot_turns)        # Class Variables        self.n_global_rotations = n_global_rotations        self.global_rot_groups = global_rot_groups        self.global_rot_turns = global_rot_turns                self.n_plane_rotations = n_plane_rotations        self.plane_rot_groups = plane_rot_groups        self.plane_rot_turns = plane_rot_turns        self.dim = dim        self.tile_cubes = tile_cubes        self.axis_col_map = axis_col_map        self.axis_plane_map = axis_plane_map        self.plane_rot_coords_map = plane_rot_coords_map        self.axis_coord_planes_map = axis_coord_planes_map        self.surface_coords = surface_coords        self.set_external_faces()        self.set_plane_tiles_map()                if verbose is True:            print(self.__repr__())            # All cube tiles    def get_tiles(self):        return self.tile_cubes            # External Faces lookup    def get_external_faces(self):        return self.external_faces            def set_external_faces(self):        external_faces = {}        for tc_name, tc in self.tile_cubes.items():            for face_name, face in tc.get_external_faces().items():                external_faces[(tc_name, face_name)] = face        self.external_faces = external_faces    # Plane <=> Tile Mapping (called after all rotations)    def set_plane_tiles_map(self):        plane_tile_map = {}        for plane_rot, coord in self.plane_rot_coords_map.items():            col = self.axis_col_map[plane_rot.axis]            plane_tile_map[plane_rot] = {tc_name: tc for tc_name, tc in self.tile_cubes.items() if tc.origin[col] == coord}        self.plane_tile_map = plane_tile_map        self.set_external_faces()        self.set_surfaces()    def get_surfaces(self):        return self.surface_faces        #    # Global Rotations    #    def get_global_rotations(self):        return self.global_rot_turns    def get_global_rotation_tiles(self) -> 'dict':        global_rotation_tiles = self.tile_cubes        return global_rotation_tiles    def global_rotation(self, rot, verbose=False):        assert isinstance(rot.rot, GlobalRotation), f"Rotation [{rot}] must be global"        for name, tc in self.get_global_rotation_tiles().items():            if verbose is True:                print(f"Global Rotating Tile [{name}] With [{rot}]")            tc.rotate(rot.getRotMat())        self.set_plane_tiles_map()    #    # Plane Rotations    #    def get_plane_rotations(self):        return self.plane_rot_turns            def get_plane_rotation_tiles(self, rot: RotationTurn) -> 'dict':        plane_rotation_tiles = self.plane_tile_map.get(rot.rot)        assert isinstance(plane_rotation_tiles, dict), f"{rot} is not allowed"        return plane_rotation_tiles    def plane_rotation(self, rot, verbose=False):        assert isinstance(rot.rot, PlaneRotation), f"Rotation [{rot}] must be plane"        for name, tc in self.get_plane_rotation_tiles(rot).items():            if verbose is True:                print("Plane Rotating Tile [{name}] With [{rot}]")            tc.rotate(rot.getRotMat())        self.set_plane_tiles_map()    def set_surfaces(self):        surface_faces = {}        external_faces = self.get_external_faces().values()        for cube_surface, coord in self.surface_coords.items():            axis = cube_surface.axis            faces = [face for face in external_faces if face.center[self.axis_col_map[axis]] == coord]            surface_faces[cube_surface] = faces        self.surface_faces = surface_faces        def render_voxel(self):        poscolors = ['tab:blue', 'tab:orange', 'tab:green', 'tab:red', 'tab:purple',                     'tab:brown', 'tab:pink', 'tab:gray', 'tab:olive', 'tab:cyan']                cubes = {}        inds = dict(zip(['x', 'y', 'z'], np.indices(self.dim)))        for tc_name, tc in self.tile_cubes.items():            cube = []            for axis, coord in zip(['x', 'y', 'z'], tc.origin):                plane = self.axis_coord_planes_map[(axis, coord)]                cube.append(inds[axis] == plane)            cubes[tc_name] = np.logical_and.reduce(cube)        voxels = np.logical_or.reduce(list(cubes.values()))                # set the colors of each object        colors = np.empty(voxels.shape, dtype=object)        for tc_name, cube in cubes.items():            colors[cube] = poscolors[(tc_name) % len(poscolors)]                # and plot everything        fig = plt.figure()        ax = fig.add_subplot(projection='3d')        ax.voxels(voxels, facecolors=colors, edgecolor='k')                axlim = np.max(self.dim)                ax.set_xlim3d(0, axlim)        ax.set_xlabel('y-hat')        ax.set_ylim3d(0, axlim)        ax.set_ylabel('x-hat')        ax.set_zlim3d(0, axlim)        ax.set_zlabel('Z')                plt.show()