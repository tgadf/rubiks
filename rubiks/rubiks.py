""" Rubik's Cube Container Class """__all__ = ["RubiksCube"]from copy import deepcopyimport numpy as npfrom gym.utils import seedingimport randomfrom .cube import Cubefrom .cubesurface import CubeSurfacefrom .state import RubiksCubeStatefrom .rubikscolors import RubiksColorsclass RubiksCube:    def __repr__(self):        return f"RubiksCube(dim={self.dim}, seed={self.seed}, color_scheme={self.coloring_scheme})"            def __init__(self, dim: tuple = (2, 2, 2), color_scheme: str = ("surface", 6), seed=0):        # Set numpy seeding for repeated randomness        self.np_random, self.seed = seeding.np_random(seed)        # Assert dimensions are correctly given        dim = (dim, dim, dim) if isinstance(dim, int) else dim        assert isinstance(dim, tuple), f"dim [{dim}] must be a tuple of ints"        assert all([isinstance(val, int) for val in dim]), f"dim [{dim}] must be a tuple of ints"        # Build Cube        self.dim = dim        self.cube = Cube(*dim)        self.set_face_colors(color_scheme)        self.history = []        self.set_state()        self.init_state = deepcopy(self.curr_state)        self.randomize_history = None                # Set Fixed Corner Face        self.set_fixed_face()        # Possible Actions        self.actions = self.cube.get_plane_rotations()        self.n_actions = len(self.actions)        print(self.__repr__())            def get_curr_fixed_face(self):        faces = self.cube.get_surfaces()[self.fixed_face_surface]        retval = next(iter([face for face in faces if np.array_equal(self.fixed_face_coords, face.center)]))        return retval                            def set_fixed_face(self):        # Front (y, -) , Top (z, +), Right (x, +) Face is Fixed        self.fixed_face_surface = CubeSurface('y', '-')        faces = self.cube.get_surfaces()[self.fixed_face_surface]        coords = np.max(np.array([face.center for face in faces]), axis=0)        self.fixed_face = next(iter([face for face in faces if np.array_equal(coords, face.center)]))        self.fixed_face_coords = self.fixed_face.center    # State Dictionary    def set_state(self):        def face_key(face):            return self.pos_colors[face.getAttr('color')]                self.curr_state = RubiksCubeState(self.cube.get_surfaces())    # Done (terminated) requirement (all faces have colors equal to their original values)    def is_done(self):        return self.init_state == self.curr_state    def randomize(self, depth: int = 10, verbose=False):        for _ in range(depth):            self.random_action(verbose=verbose)        self.randomize_history = deepcopy(self.history)        self.history = []    def random_action(self, verbose=False):        action = self.np_random.choice(self.actions)        if len(self.history) > 0:            while action == self.history[-1].getInv():                action = self.np_random.choice(self.actions)        self.action(action, verbose=verbose)        def action(self, rotation, verbose=False):        def rotate_to_fixed_face(rotation):            curr_fixed_face = self.get_curr_fixed_face()            if curr_fixed_face.getAttr('uid') != self.fixed_face.getAttr('uid'):                invrot = rotation.getGlobalInv()                self.cube.global_rotation(invrot)                        if verbose is True:            print(f"  Action[{len(self.history)}] = {rotation} ... ", end="")                    self.cube.plane_rotation(rotation)        rotate_to_fixed_face(rotation)        self.history.append(rotation)        self.set_state()                if verbose is True:            print(self.is_done())        def color_scheme(self, scheme):        def set_surface_colors(surface_colors):            for surface, faces in self.cube.surface_faces.items():                for face in faces:                    face.setAttr("color", surface_colors[surface])                def gen_face_indices(n_faces, n):            retval = set()            n = n_faces - 1 if n >= n_faces else n            while len(retval) < n:                retval.add(random.randrange(n_faces))            return retval        self.color_scheme = scheme        rcolors = RubiksColors()        if scheme[0] == "surface":            if scheme[1] == 6:                surface_colors = dict(zip(self.cube.surface_faces.keys(), rcolors.get_color_cycle(6)))                set_surface_colors(surface_colors)            elif scheme[1] == 3:                surface_colors = dict(zip(self.cube.surface_faces.keys(), rcolors.get_color_cycle(3)))                set_surface_colors(surface_colors)            elif scheme[1] == 2:                surface_colors = dict(zip(self.cube.surface_faces.keys(), rcolors.get_color_cycle(2)))                set_surface_colors(surface_colors)        elif scheme[0] == "face":            surface_colors = dict(zip(self.cube.surface_faces.keys(), rcolors.get_color_cycle(scheme[1])))            set_surface_colors(surface_colors)            for surface, faces in self.cube.surface_faces.items():                for idx in gen_face_indices(len(faces), scheme[2]):                    faces[idx].setAttr("color", rcolors.get_color_by_pos(scheme[1] + 1))    