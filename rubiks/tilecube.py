""" Basic 3D cube convention class """__all__ = ["TileCube"]import numpy as npfrom .axis import Axisfrom .face import Faceclass TileCube:    def __repr__(self):        return f"TileCube(name={self.name}, origin={self.origin}, scale={self.scale}, attrs={self.attrs})"        def __init__(self, origin: np.ndarray = None, scale: int = 1, name: str | int = None, verbose=False):        """               ---------              /  top   /|             /        / |            ---------   |    <== left            |       |   |    ==> right            | front |   /    V bottom            |       |  /     ^ top            --------- /        """                self.ax = Axis()        self.name = name        self.verbose = verbose        self.scale = scale        self.attrs = {}        origin = np.array(origin) if isinstance(origin, (list, tuple)) else origin        self.origin = origin if isinstance(origin, np.ndarray) else np.array([0, 0, 0])        self.faces = {}        self.set_faces(scale)    def generate_faces(self, scale: float = 1) -> 'np.ndarray':        faceAxes = list(zip([self.ax.x_hat, -self.ax.x_hat, self.ax.y_hat, -self.ax.y_hat, self.ax.z_hat, -self.ax.z_hat],                            ["right", "left", "top", "bottom", "front", "back"]))        faces = {}        for axis, name in faceAxes:            faces[name] = Face(center=(self.origin + scale * axis / 2), name=name)        return faces    def set_faces(self, faces: dict = None, scale: int = 1) -> 'None':        self.faces = faces if isinstance(faces, dict) else self.generate_faces(scale=scale)    def get_face_centers(self):        centers = np.array([face.center for face in self.faces.values()])        return centers    def extend_faces(self) -> 'list':        return self.generate_faces(scale=2)    def get_external_faces(self):        external_faces = {face_name: face for face_name, face in self.faces.items() if face.getAttr("external") is True}        return external_faces    def translate(self, vec: np.ndarray) -> 'None':        self.origin = np.add(self.origin, vec)        self.set_faces()    def rotate(self, mat: np.ndarray) -> 'None':        self.ax.rotate(mat)        self.origin = mat.dot(self.origin)        faces = self.generate_faces()        face_attrs = {name: face.attrs for name, face in self.faces.items()}        for name, face in faces.items():            face.attrs = face_attrs[name]        self.set_faces(faces)    def getFaceAttr(self, face: str, attr: str) -> 'str | bool':        return self.faces[face].attrs.get(attr)    def setFaceAttr(self, face: str, attr: str, value: str | bool) -> 'None':        self.faces[face].attrs[attr] = value    def contains(self, pnt: np.ndarray | list | tuple) -> 'bool':        pnt = np.array(pnt) if isinstance(pnt, (list, tuple)) else pnt        assert isinstance(pnt, np.ndarray), f"pnt [{pnt}] is illegal"        centers = self.get_centers()        faces_max = np.max(centers, axis=0)        faces_min = np.min(centers, axis=0)        for val, min_val, max_val in zip(pnt, faces_min, faces_max):            if val > max_val or val < min_val:                return False        return True